# Getting Started With the iot-state-processing-dsl language  

## Overview
IoT-state-processing-dsl language is language that the users can use to write their own rules. The users can define a sequence of operations under certain conditions, on certain frequencies, or over a certain period of time. The main operations include accessing data received by DSL, doing arithmetic operations over the data, and sending data to the cloud. 

## Pre requisites  
* Java 8  
* iot-state-processing-dsl jar - Jar file can be found at root of this project. Jar file usage can be found in [ReadMe](README.md).    
* There are 3 kind of files that users have to create:   
	* <name>.rules file - This file contains the rules which user wants to apply on their data.  
	* <name>.data file - This file contains the sample user data  
	* <name>.output file - This file will be the output file generated by the jar.  
	

## Sample Data  
Sample data file for all rules mentioned below can be found at [Sample Data File](tutorial/genericData.data).      

## Writing rules    

### KeyWords Reserved    


| Keywords      | Keywords      | Keywords  | Keywords  | Keywords  |
|:-------------:|:-------------:|:-----:|:-----:|:-----:|
| LOG/log      | JSON/json | topic/TOPIC |  THEN/then |  throttle/THROTTLE |
| msg      | init  |   PAYLOAD |  TO/to |  print/PRINT |
| SEND/send | when/WHEN    |   for/FOR |  cos |  change |
| rule_time | rule_id    |   abs |  prev |  LOG_LEVEL/log_level |
| TS_UPDATE | WITH/with | WINDOW/window | ts_avg | ts_count |
| in-msg/IN-MSG/in msg/IN MSG | else/ELSE | trace | debug | info | 
| warn | error | prop/PROP | data/DATA | in/IN |
| s/sec | m/min | ms/milliseconds | sin | true/TRUE |
| false/FALSE | WHILE/while | at/AT | epoch_now| subtree |  
| scol | DEVICE/device |

### Comments in DSL  
Comments can be introduced using double hyphen('--'). For example - 
```  
-- This line introduces how to write comments using this DSL  
```   

### End of line   
End of line is represented by ';' or 'scol'.   

### Changing Log level   
The log level can be changed by using LOG_LEVEL keyword.  

**syntax**  
*LOG_LEVEL \<level\>;*  
where   
*level* is trace,debug,info,warn,error  

The example is shown below  
```   
LOG_LEVEL trace;   
```   

### Variables  
* **Global variables**  - Global variables can be introduced anywhere in the file using keyword *init*.   
```  
-- This block introduces how to declare single global variable.
init i=2;

-- This block introduces how to declare multiple global variable.
init {
	a=1020;
	b=1000;
}
```  
* **Local variables**  - Local variables can be introduced anywhere in the scope.  

### Printing or Logging statements  
Log statements can be printed using following code. Both log and print can be used interchangeably.   
```  
LOG "Showing how to log";
PRINT "Showing how to log";
```   

### Arithmetic Operators  
These are the Arithmetic operators supported by DSL language.   
     
| Operator    | Description    | Example   |
|:-------------:|----------------|-----------|
| +  (Addition)  		    | Adds values on either side of the operator.  | a + b |
| -  (Subtraction)          | Subtracts right-hand operand from left-hand operand.      |    a - b |
| *  (Multiplication)           | Multiplies values on either side of the operator.   |   a * b |
| /  (Division)	          | Divides left-hand operand by right-hand operand.  |    a / b |
| ^   (Power)          | Applies the power of right operand on the left operand.     |   a ^ b |

###  Comparison Operators  
These are the relational operators supported by DSL language.    

| Operator    | Description    | Example   |
|:-------------:|----------------|-----------|
| =  (assignment)  		    | Assigns value on right to variable on left  | a = 1 |
| ==  (equal to)          | Checks if the values of two operands are equal or not, if yes then returns true.       |    a == b |
| >  (greater than)           | Checks if the value of left operand is greater than the value of right operand, if yes then returns true.       |   a > b |
| >=  (greater than or equal to)	          | Checks if the value of left operand is greater than or equal to the value of right operand, if yes then returns true.       |    a >= b |
| <   (less than)          | Checks if the value of left operand is less than the value of right operand, if yes then returns true.       |   a < b |
| <=  (less than or equal to)          | Checks if the value of left operand is less than or equal to the value of right operand, if yes then returns true.       |    a <= b |

### The Logical Operators
The following table lists the logical operators âˆ’    

| Operator    | Description    | Example   |
|-------------|----------------|-----------|
| \|\|  (logical or)  		    | If any of the two operands are non-zero, then the condition becomes true.  | a \|\| b |
| &&  (logical and)          | If both the operands are non-zero, then the condition becomes true. |    a && b |
| !  (logical not)           | Used to reverse the logical state of operand. If a condition is true then Logical NOT operator will make it false.     |    !a |

### Strings 
* String init  
```  
string1 = "Hello" ;
```    
* Checking if strings are equal  
```  
string1 == string2
```   
* String manipulations
1. substr: get a substring out of a string by specifying left and right boundary. Left index is inclusive and right index is exclusive.
```
LOG substr("avgTemp", 0, 3);
-- output will be "avg"
```
2. contain: test if the bigger string contains the smaller string. If yes, then the starting index in the bigger string will be returned; if not, then -1 will be returned.
```
LOG contain("bigString", "String");
-- output will be "3"

LOG contain("bigString", "StrING");
-- output will be "-1"
```
3. reverse: reverse the input string
```
LOG reverse("input");
-- output will be "tupni"
```
4. replace: replace all the certain pattern of substrings into another string
```
LOG replace("tempPressure and tempHumid", "temp", "current");
-- output will be "currentPressure and currentHumid"
```
5. decompress: decompress the input into longer format. The characters in the original string are guaranteed to be 'a' - 'z'; the number of repetition is in [0,9].
```
LOG decompress("c1u1r2e1n1t1");
-- output will be "current"
```

### Date conversions
* Convert unix timestamp to a date
 **Syntax** -<br />
 *LOG unixtodate(timestamp, timeZoneofTimestamp, dateFormat);*

```
-- convert unixtime at GMT timezone to a certain format
LOG unixtodate(1497012000, "GMT", "yyyy-MM-dd'T'HH:mm:ss.SSS Z");
-- output will be "2017-06-09T12:40:00.000 +0000"
```
* Convert a date to unix timestamp
 **Syntax** -<br />
 *LOG datetounix(date, timeZoneofDate, dateFormat);*

```
-- convert a date at certain timezone to be unix timestamp
LOG datetounix("2017-06-09T12:40:00.000", "UTC","yyyy-MM-dd'T'HH:mm:ss.SSS");
-- output will be "1497012000"
```
* Convert a date from old format to a new format
 **Syntax** -<br />
 *LOG formatdate(date, oldFormat, newFormat);*

```
-- convert unixtime at GMT timezone to a certain format
LOG formatdate(2017-06-09T12:40:00.000Z, "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", "EEE, d MMM yyyy HH:mm:ss");
-- output will be "Fri, 9 Jun 2017 12:40:00"
```

### JSON transformations
Transform the structure and value of JSON into another JSON
  **Syntax** -<br />
  *LOG trans(data, spec);*
```
-- assume the incoming data is
engine;1000;{"data": "{\"prevTemp\": 60,\"currentTemp\": 80}"}

-- given the rule is 
init spec = "[{&quot;operation&quot;: &quot;shift&quot;,&quot;spec&quot;: {&quot;currentTemp&quot;:&quot;prevTemp&quot;}}]";
LOG trans(engine.data, spec);

-- output will be {"prevTemp":80}
```
Notice that the variable spec is string whose value is some JSON, where all the double quotes in the JSON should be replaced by "&quot;"
For instance, {"operation"} should be written as {&quot;operation&quot;}

### Accessing data received by the library     
* **Access Current State** - Current state of device/gateway can be accessed using *subtree*. DSL receives messages from gateways and devices connected via gateways. For every gateway, DSL aggregates data into a tree structure. This tree structure contains data from every device under the key with the name matching the device name. The data from the gateway itself ends up at the root of the structure. For example a device 'engine' sends temperature, pressure and humidity information one at a time to gateway G1. G1 might have many such devices connected to it. Getting current state of 'engine' would mean getting most up to date values of temperature, pressure and humidity sent by 'engine'.

* **Including partial subtrees** - It is also possible as of version 0.8.2 of the DSL library to specify additional parameters to the *subtree* function/keyword, specifying which children at a particular subtree to include in the output. This is useful if you want to prune data before output; examples both with and without children parameters are shown below.

 **Syntax** -<br />
 *LOG subtree(device);*
 
 or
 
 *LOG subtree(device, child1, child2, ...);*

```
-- Printing current state of device named 'engine'  
LOG "engine:" + subtree(engine) ;

-- One possible output will be
{temp:100, pressure:80, humidity:8}

-- Example of the abovs using optional subtree children parameters  
LOG "engine:" + subtree(engine, humidity) ;

-- The output would in this case be
{humidity:8}
```    

* **Access Message Components** - It is common that a device/gateway sends a complex payload which includes multiple fields, and the users can access one particular field from the message payload. Two usages are provided. First, retrieve the current value of the field from the incoming message received by the device/gateway. Second, retrieve the previous value of the field from the most recent past status stored on the device/gateway. To retrieve the current value, the users can use keyword *in-msg* or *msg* to check if this piece of data ever appears in the message, and if yes, then get access to it (examples are provided in the Decision Making section). To extract the prevous value of a field, simply use key word *prev*.

 **Syntax** -<br />
 *when\<Rule id\> \<device.field\> in-msg then \<action\>;*<br />
 *LOG msg(\<device.field\>);*<br />
 *LOG prev(\<device.field\>);*<br />

```  
-- Assume the following is the data sent to the gateway
engine;1000;{"temp": 10}
engine;1000;{"temp": 20}
engine;1000;{"temp": 30}

-- Getting the current value of the temp field from message sent by device engine
LOG "--------- MSG from device: Engine Temp: "+ msg(engine.temp);
-- The output will be
{30}

-- Getting the previous value of the temp field from past status stored on device engine
LOG "--------- MSG from device: Engine Previous Temp: "+ prev(engine.temp);
-- The output will be
{20}
```    

### Decision Making  

* **when** - A when statement consists of a boolean expression followed by one or more statements. 'When' statement can be associated with an optional rule id, consisting of only alphabets, numbers, and underscore, in angular brackets. If not specified, the library generates a random rule id and associates it with this rule. User can use rule id to identify which rule resulted in a particular action.    

 **Syntax** -   
 *when\<Rule id\> \<boolean expression\> then \<action\>;*   
 where -   
 *Rule id* - Custom rule id associated with this when rule, optional.  
 *boolean expression* - The condition you want to check.  
 *action* - The action you want to perform once condition is satisfied.   
 
 The example is shown below:   
```  
init i = 5 ;
-- Example demonstrating when rule with rule id Rule01
when<Rule01> i>0 then LOG "i is greater than 0:Rule Id:" + rule_id();

-- Example demonstrating when rule without rule id. A random rule id will be assigned.  
when i>0 then LOG "i is greater than 0:Rule Id:" + rule_id();

--Example demonstrating when with complex boolean expression. The example below checks if device engine's temperature is less than 1000 and greater than 500.
when<RuleRange> msg(engine.temp) < 1000 && msg(engine.temp) > 500 then {
	LOG "Within Range Alert" + ":Rule Id:" + rule_id() ;
}
```  

* **when...then...else...** - A when statement can be followed by an optional else statement, which executes when the boolean expression is false.  'When' statement can be associated with an optional rule id in angular brackets. If not specified, the library generates a random rule id and associates it with this rule. User can use rule id to identify which rule resulted in a particular action.    

 **Syntax** -   
 *when\<Rule id\> \<boolean expression\> then {*   
	*\<action1\>;*   
 *} else {*   
	*\<action2\>;*   
 *}*         
 where -     
 *Rule id* - Custom rule id associated with this when rule, optional.    
 *boolean expression* - The condition you want to check.    
 *action1* - The action you want to perform once condition is satisfied.    
 *action2* - The action you want to perform once condition is not satisfied.     

The example is shown below:   
```  
--Log "Greater than low_limit" when temperature is greater than 950
--Log "Lower than low_limit" when temperature is less than 950
low_limit = 950;
when<RuleIf> msg(engine.temp) > low_limit  then {
	LOG "Greater than low_limit, If" + ":Rule Id:" + rule_id() ;
} else {
	LOG "Lower than low_limit, If" + ":Rule Id:" + rule_id() ;
}
```  
* **Nested when** - You can use one when then else statement inside another when then else statement(s).   

 **Syntax** -   
 *when\<Rule1\> \<boolean expression\> THEN  {*    
	*when\<Rule1a\> \<boolean expression\> then {*    
		*\<action1\>;*   
	*}*    
 *}*   
 *else when\<Rule2\> \<boolean expression\> then {*     
	*when\<Rule2a\> \<boolean expression\> then {*   
		*\<action2\>;*   
	*}*   
 *}*      
  
The example is shown below:  
```  
-- Check if device brakes is sending temperature in current message and if that temp > 5, log "Brake temp greater than 5".
-- Check if device engine is sending temperature in current message and if that temp > 5, log "Engine temp greater than 5".
when<Rule1> brakes.temp in-msg THEN  { 
	when<Rule1a> msg(brakes.temp) > 5 then {
		LOG "Brake temp greater than 5" ;
	}
}
else when<Rule2> engine.temp in-msg then { 
	when<Rule2a> msg(engine.temp) > 5 then {
		LOG "Engine temp greater than 5" ;
	}
} 
```   

### Send Statement/ Actions  
In order to associate a message from gateway/device with an action, *send* method is used. *send* is associated with few more keywords like:  
 * **TO** - The string after this keyword specifies the destination for this message. The destination can then be used for further processing based on user specification. *At this moment it is ignored, and will be introduced in future releases*.     
 * **TOPIC** - The string after this keyword specifies the topic which can be used as a tag for this message.
 * **DEVICE** - The string after this keyword specifies the device/asset name on behalf of which this message will be sent.
 * **JSON or PAYLOAD/DATA** - The action that is generated with send specifies that we want to send either the current state of device as a *JSON* or we want to send a custom string using keyword *PAYLOAD/DATA*.  
The keyword *AS_BATCH* or *as_batch* can be used if the users want to use batch manager to send payloads from device/gateway to the cloud. If this keyword is not specified in the DSL, then by default DSL will not use batch manager. 
**Syntax** -   
*SEND TO "\<destination\>" (AS_BATCH) TOPIC "\<topic name\>" (DEVICE "\<asset name\>") JSON deviceName;*   
or  
*SEND TO "\<destination\>" (AS_BATCH) TOPIC "help" (DEVICE "\<asset name\>") PAYLOAD "\<custom string\>";*  
where  
*destination* - The destination you want to send your message to.  
*topic name* - The topic name to be attached to the existing topic. For example if topic is /v1/gw:device/json/dev2app/ then this command will modify the topic name to /v1/gw:device/json/dev2app/\<topic name\>  
*asset name* - Optional; specifies that a generated message should be sent on behalf of a particular device or asset. In other words, this will signal to the rule engine to send on the topic for the specified device.  
*deviceName* - If you are sending json then mention the device name here for which you want to send it's current state.  
*custom string* - If you are using payload, then you can mention custom string here.  

Examples for various combinations are shown below:  
```
--Send an Action to "Starlord" with topic "help" and send json like engine's current status
SEND TO "Starlord" TOPIC "help" JSON engine;

--Send an Action to "Starlord" with topic "help" on behalf of device "engine2" and send json like engine's current status
SEND TO "Starlord" TOPIC "help" DEVICE "engine2" JSON engine;

--Send an Action to "Drax" with topic "help" and send json - engine temperature only
SEND TO "Drax" TOPIC "help" JSON engine.temp;

--Send an Action to "Flash" with topic "help" and send json like engine and brakes' current status
SEND TO "Flash" TOPIC "help" JSON engine, brakes;

--Send an Action to "IronMan" with topic "help" and send PAYLOAD message too. PAYLOAD can be replaced by DATA too.
SEND TO "IronMan" TOPIC "help" PAYLOAD "Pressure level seriously high";
SEND TO "IronMan" TOPIC "help" DATA "Pressure level seriously high"; 

--Send an Action to "Warn" using batch manager with topic "tempHigh" and send json like engine's current status
SEND TO "Warn" AS_BATCH TOPIC "tempHigh" JSON engine;

--Send an Action to "Record" with topic "temp" and send json - engine temperature only
SEND TO "Record" AS_BATCH TOPIC "temp" JSON engine.temp;
```  

### Throttle   
*Throttle* keyword can be used to control the rate at which we are generating actions like *send*. This is mostly used for reducing the number of actions generated if a condition is always met. The throttle keyword is followed by the time, in parenthesis with unit of time, in which you want to send the action. For example, throttle(5s) means send the action once every 5s. The unit of time available are *s* for seconds, *ms* for millisecond and *m* for minutes. It is possible to attach a rule id to throttle in angular brackets. If not specified, the library generates a random rule id and associates it with this rule. User can use rule id to identify which rule resulted in a particular action.           

**Syntax** -   
*throttle\<Rule Id\> (time IN time_unit)    
or    
throttle<Rule Id> (time time_unit)*     
where    
*Rule Id* - optional.  
*time* - It's an integer. The time in which the action should be sent. It is combined with time_unit to decide at what frequency should the action be generated.      
*IN* - optional  
*time_unit* - *s* for seconds, *ms* for millisecond and *m* for minutes     

```   
--The example below assigns rule id Throttle1 to throttle command. The example below curtails the print statement to once every 5s even though condition is always met.
init i = 2 ;
when<Rule1> i>1 then {
      -- Print "Hi: " + rule_id() after the 0th, 5th, 10th, 15th second of the function has been called and so on 
      throttle<Throttle1> (5 IN s) PRINT "Hi:" + rule_id();

}

--Based on temperature difference between 2 messages decide the level of importance and hence frequency of sending message
--Engine Temperature difference between 2 consecutive messages is greater than 10, send message every 1min to EMAIL/TEMP_CHANGED_10. - DEFCON 1
--Engine Temperature difference between 2 consecutive messages is greater than 50, send message every 1ms to EMAIL/TEMP_CHANGED_50. - DEFCON 2
when abs(msg(engine.temp) - prev(engine.temp)) > 50 THEN THROTTLE(1 ms)  {
	LOG "Implementing rule:" + rule_id(); 	
	SEND TO "starlord" TOPIC "EMAIL/TEMP_CHANGED_50" JSON engine;
}
when abs(msg(engine.temp) - prev(engine.temp)) > 10 THEN THROTTLE(1 m)  {
	LOG "Implementing rule:" + rule_id();
	SEND TO "starlord" TOPIC "EMAIL/TEMP_CHANGED_10" JSON engine;
}
```     

### For Statement  
The for usage in this library is slightly different as compared to the once used in Java/C/C++/Python etc. *for* is used with conditional statements. It is used to check that condition is true not just once but within a defined time interval. For example if engine temperature is greater than some threshold between 2 to 5 seconds (mathematically written as [2,5)), then the rule generates some action only between the second to the 5th second. If max limit is not provided then [0x7fffffffffffffff] is taken as default max value.     

**Syntax** -     
*for(start_time:stop_time in time_unit)     
or    
for(start_time:stop_time time_unit)*       
where  
*start_time* - 0 to [0x7fffffffffffffff]  
*stop_time* - 0 to [0x7fffffffffffffff], optional  
*in* - optional to specify  
*time_unit* - *s* for seconds, *ms* for millisecond and *m* for minutes  
*start_time* is inclusive, *stop_time* is exclusive
```    
--Min and max time limit provided. The condition should be true between min and max time and only then take some action
--Example if i>1 between 2 to 5s, then log something between 2-5s
when i>1 for(2:5 in s) then LOG "i greater for the duration:" + rule_id();

--Min limit provided. The condition should be true only between min and max(taken as 9223372036854775807 or [0x7fffffffffffffff] by default) and only then log something
when<RuleFor2> i>1 for(2: in s) then {
	LOG "i greater for the duration:" + rule_id();
}
```     

### Time Series(TS)     
A time series is a series of data points indexed in time order. A time series can be maintained by this library. The attributes from a message can be stacked separately in different time series and then their total count or average can be calculated using 2 methods provided in the library called ts_avg and ts_count.   

**Syntax** -      
*TS_UPDATE \<ts_name\> WITH \<y-axis attr\> AT \<x-axis attr\> WINDOW (\<time\> \<time_unit\>);*    
*avg = ts_avg(\<ts_name\>);*   
*count = ts_count(\<ts_name\>);*     
where     
*ts_name* - Name of the time series  
*y-axis attr* - The message attribute for an device which is added to time series.  
*x-axis attr* - optional to specify. The message attribute for an device against which TS is constructed.   
*time* - The time window for which TS is maintained after which the window starts sliding.     
*time_unit* - *s* for seconds, *ms* for millisecond and *m* for minutes    

```   
--Create a time series object for engine temperature from message against the message timestamp for a 3s window
--For example below, x-axis is time and y-axis is temperature. 
--Object always captures 3s window worth of data. Then it slides.
TS_UPDATE tempTSObjTime WITH msg(engine.temp) WINDOW (3 sec);

--Create a time series object for engine temperature from message against the message number for a 5 message window. Only 5 messages are maintained. Then it slides to next 5
--For example below, x-axis is message number and y-axis is temperature
TS_UPDATE tempTSObjMsgSeq WITH msg(engine.temp) AT engine.msg WINDOW (5);

--Create a time series object for engine temperature from message against the message timestamp for a 3s window
--Calculate average temperature and count members in time series object.
--Check if number of members is greater than 1. If yes, log it
--Check if avg temperature is greater than 500. If yes then send Action 
TS_UPDATE tempTimeSeries WITH msg(engine.temp) WINDOW (3 sec);
temp_avg = ts_avg(tempTimeSeries);
temp_count = ts_count(tempTimeSeries);
WHEN temp_count > 1 THEN LOG "Time Series Temperature Count:" + temp_count ;
WHEN temp_avg > 500 THEN {
	LOG "Time Series Temperature Avg:" + temp_avg ;
	SEND TO "internal-rmq" TOPIC "alertTemp" JSON engine;
}

```    

## Examples for rules above  
Detailed examples for each rule explained above can be found at [Detailed Examples](tutorial).          

 






